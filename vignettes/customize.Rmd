---
title: "customize"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{customize}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Customize

In `rsat`, ***customizing*** means transforming raw images into useful information for particular needs. Customizing includes:

1.  

2.  

3.  

------------------------------------------------------------------------

### Mosaic {#basic-mosaic}

***Mosaicking*** involves binding together several images of a region from the same date. The function `mosaic()` finds automatically the relevant images in the database and joins them together in a single file. Additionally, by default, the function crops around the `roi` of an `rtoi` to remove unnecessary information and save space on your hard disk drive:

```{r, eval=FALSE}
mosaic(filomena)
```

The cropping option can be disabled with the argument `warp = NULL`. Here, cropping is appropriate since images extend far beyond our region of interest.

The results are saved in the `rtoi_path` inside a sub-folder called *mosaic*. This is the first time in the workflow that the `rtoi_path` is being used since mosaicking is the first transformation applied to the raw images to better fit the particular needs of the analysis. The outcomes from the mosaic are compressed (*zip)* to minimize their size:

```{r, eval=FALSE}
list.files(rtoi_path(filomena), full.names = TRUE, recursive = TRUE)
```

### Index calculation {#index-calculation}

#### Definition

A ***remote sensing index*** is an indicator that reveals the presence of a material in a satellite image. Indexes are the result of simple math applied to the bands of an image. The computation involves the bands with a distinctively high or low reflectance. Over the years, researchers have developed a wide variety of indexes for different materials or processes which can be consulted [here](https://www.indexdatabase.de/db/i.php).

For instance, the *Normalized Difference Snow Index* (NDSI) (see e.g., [@ndsi2004]) highlights the snow using the *green* and *shortwave-infrared* bands (around $1.5 \mu m$). The subtraction of this two bands gives a large number for those pixels showing snow. The denominator ensures that values oscillate between $-1$ and $1$.

$$ NDSI = \frac{Green - SWIR1}{Green + SWIR1}$$

#### Calculation

In `R` we can create a function replicating the calculation of the *NDSI:*

```{r basic_ndsi, eval = FALSE}
NDSI = function(green, swir1){
  ndsi <- (green - swir1)/(green + swir1)
  return(ndsi)
}
```

A nice feature of `rsat` is that formulas must use the band names, e.g. *red, green, blue, etc.* rather than band number. Band names and numbers differ among mission/satellite. For instance, the *green* corresponds to the band number $4$ in MODIS and Landsat-7, number $3$ in Landsat-8 and Sentinel-2, and number $6$ in Sentinel-3 (see [here](https://drive.google.com/file/d/1cSw4LaTLPlGBHmG8v7uwH54f-m9jZz1N/view?usp=sharing)). With names, you can apply a unique custom function across satellites/missions and `rsat` functions will take care about which name corresponds to which band in each mission. Some widespread variables are built-in the package. The list of variables can be printed using;

```{r basic_variables}
show_variables()
```

To use the `NDSI` function over the series of satellite images from the Iberian peninsula type;

```{r basic_derive, eval = FALSE}
derive(filomena, product = "mod09ga", variable = "ndsi", fun = NDSI)
```

Import the results into `R` using the `get_raster()` function. The numbers must be truncated between $-1$ and $1$ to avoid values outside the feasible range (sun reflections on mirror-like surfaces, such as water, can lead to misleading results):

```{r basic_ndsi_import, eval = FALSE}
ndsi.img <- get_raster(filomena, "mod09ga", "ndsi")
ndsi.img <- clamp(ndsi.img, -1, 1)
```

Let's display one of the results:

```{r basic_ndsi_plot, eval = FALSE}
library(tmap)
tm_shape(ndsi.img[[1]]) + tm_raster(style = "cont")
```

The *NDSI* index improves the separability between clouds and snow. However, there might be some difficulties distinguishing between them in certain parts of the image. Therefore, in the next step, cloud-covered pixels are removed.

### Cloud removal {#cloud-removal}

Some data providers apply algorithms over their data-sets to detect the presence of clouds (Level 1/2 products). The analysis is part of the quality assessment done during pre-processing and the results are included in the ***Quality Assurance*** (*QA*) band of the image. In addition to cloud coverage, the band provides information about over-saturated or filled pixels. The information is packed in this band using the bit format.

The function `cloud_mask()` interprets the *QA* band to obtain images showing the presence/absence of clouds. Its application is straightforward;

```{r basic_cloud, eval=FALSE}
cloud_mask(filomena)
```

For every image in the `rtoi`, the function generates a new image, called ***mask***, in which $1$s and $NA$s indicate clear and covered pixels. The function identifies the mission/program and applies the appropriate interpretation of bits to create the cloud mask. To import the result run;

```{r basic_mask, eval = FALSE}
clds.msk <- get_raster(filomena, "mod09ga", "CloudMask")
```

In MODIS, cloud-masks have a different resolution than the multispectral image. To adjust the resolution, *resample* the image (`resample()`) using the nearest neighbor method (`"ngb"`).

![Resampling the resolution to a finer scale using the nearest neighbor method](imgs/resample.PNG "Resampling the resolution to a finer scale using the nearest neighbor method")

```{r basic_mask_resample}
clds.msk <- resample(clds.msk, ndsi.img, method = "ngb")
```

To apply the cloud mask, we just multiply both series of pixels. Dot multiplications are performed pixel-wise. *NDSI* values multiplied by $1$ remain unaltered but those multiplied by $NA$ become missing:

```{r basic_mask_apply}
ndsi.filt <- ndsi.img * clds.msk
names(ndsi.filt) <- names(clds.msk) # keep the names
```

As an attempt to obtain a ***composite image***, we extract maximum value of the *NDSI* for each pixel in the time series. Maximum value compositions are frequent in this field [@mvc1986]. Compositing is as a way to summarize the information in a time-lapse and ignore the presence of clouds:

```{r basic_composite}
snow.spain <- calc(ndsi.filt, max, na.rm = TRUE)
```

Represent the results;

```{r basic_ndsi_map}
tm_shape(snow.spain) + tm_raster(style = "cont")
```
