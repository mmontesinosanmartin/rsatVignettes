---
title: "process"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{process}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

### Filling missing data {#filling}

#### Theoretical background

As mentioned earlier, cloud removal or sensor failures can lead to data gaps in time-series of satellite images. Additionally, noise from aerosols, dust, and sensor measurement errors can reduce the quality of the remotely sensed data. The ***Interpolation of Mean Anomalies (IMA***) is a gap-filling and smoothing approach that mitigates these issues [@ima2019]. `rsat` implements a generic version of the algorithm with the function `smoothing_image()`.

![Neighborhood definition in the Interpolation of Mean Anomalies, assuming `nDays = 1` and `nYears = 1`](images/neighborhood_ima.png "Neighborhood defintion in IMA")

For the theoretical explanation, let's assume $15$ images have been downloaded and processed (squares in the image above). The imagery corresponds to $5$ consecutive days over $3$ years. Consider that we are willing to fill/smooth the target image (red square). *IMA* fills the gaps borrowing information from an *adaptable* temporal neighborhood (yellow squares). Two parameters determine the size of the neighborhood; the number of days before and after the target image (`nDays`) and the number of previous and subsequent years (`nYears`). Both parameters should be adjusted based on the temporal resolution of the of the time-series of images. We recommend that the neighborhood extends over days rather than years, when there is little resemblance between seasons. Also, cloudy series may require larger neighborhoods.

![Summarized algorithm of the Interpolation of Mean Anomalies](images/ima_technique.png "IMA summarized algorithm")

*IMA* gives the following steps; (1) creates a representative image of the neighborhood ignoring missing values e.g., doing the mean, median, etc. for each pixel's time-series (`fun`), (2) the target and representative images are subtracted giving an image of *anomalies*, (3) the *anomalies* falling outside the quantile limits (`aFilter`) are considered outliers and therefore removed, (4) it aggregates the anomaly image into a coarser resolution (`fact`) to reveal potential spatial dependencies, (5) the procedure fits a spatial model (thin plate splines or *TPS*) to the anomalies which is then used to interpolate the values at the original resolution, and (6) the output is the sum of the interpolated anomalies and the average image. The process is encapsulated in `smoothing_image()` and the section below shows its usage.

------------------------------------------------------------------------

#### Hands-on demonstration

##### Data

Let's start where we left off in the previous chapter. Load the series of the *Normalized Difference Snow Index* of the Iberian Peninsula from January $10^{th}$ to $15^{th}$ , $2021$. The scenes are available in `rsatExtra` and can be loaded as follows;

```{r advanced_ima_data}
library(rsat)
data("ex.ndvi.navarre")
```

And check the results:

```{r advanced_ima_show}
library(tmap)
tm_shape(ex.ndvi.navarre) + tm_raster(style = "cont")
```

##### Interpolation of Mean Anomalies

The instruction below applies the *IMA* on the $3^{rd}$ image taking a temporal neighborhood of $2$ days, using the `mean` to generate the representative image, using the frequent $5-95$ quantile range, and aggregating the anomalies at a factor of $10$ (every $10$ pixels are aggregated into $1$):

```{r advanced_ima}
library(rsat)
ndvi.fill <- smoothing_images(method = "IMA",
                              ex.ndvi.navarre,
                              nDays = 2,
                              nYears = 0,
                              fun = mean,
                              aFilter = c(0.01,0.91),
                              fact = 10,
                              only.na = TRUE)
```

Note the last argument `only.na = TRUE`, which means that the prediction is only made for the missing pixels while the observed values are preserved. Let's make a comparison between *before* and *after* the application of *IMA.*

```{r advanced_ima_result}
before <- ex.ndvi.navarre[[1]]
after <- ndvi.fill
tm_shape(stack(before,after)) + tm_raster(style = "cont")
```
